#!/usr/bin/python3
#
# LICENSE: CC0
#
# To the extent possible under law, the person who associated CC0 with
# this file has waived all copyright and related or neighboring rights
# to this file.
#
# You should have received a copy of the CC0 legalcode along with this
# work.  If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
#

# Create a tileset and tilemap from an input "example" image file.
#
# The intent is to use it on an example level, from an old 8-bit
# game like Pacman, Super Mario Bros or The (Original) Legend of Zelda,
# and automatically create a tileset and tilemap from it.
#
# For example, using the `demo_pacman.png`, run as follows:
#
#   ./map2tile.py -i demo_pacman.png -s 8
#

import os
import sys
import json
from PIL import Image
import png
import math

import getopt

id2chr_map = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ`~!@#$%^&*()_-+=[]{}\\|;:'\",.<>/?"

info = {
  "opt": {
    "tile_zero_boundary_condition":True,
    "basedir": "./",
    "rule_weight": False, #True,
    "tile_weight": "inversesqrt", #"linear", # 1, sqrt, linear, inverse, inversesqrt
    "neighbor_type": 0,
    "debug": False
  },
  "tilemap": {"fn":"out_tilemap.json", "width":-1, "height":-1, "realize": False },
  "tileset": {"fn": "out_tileset.png", "width":-1, "height":-1, "stride":[-1,-1], "count":0, "realize":False },
  "tilerule": {"fn":"out_rule.csv", "realize":False },
  "tilename": {"fn":"out_name.csv", "realize":False },
  "firstgid": -1,
  "offset": [0,0],
  "size": [0,0],
  "stride": [16,16]
}

def usage(fp):
  fp.write("\nusage:\n")
  fp.write("\n")
  fp.write("  map2tile [-h] [-v] [-V] [-i inputfile] [-s stride] [-o offset]\n")
  fp.write("\n")
  fp.write("  -i        input file (png)\n")
  fp.write("  -s        stride (default " + str(info["stride"][0]) + ") (width,height)\n")
  fp.write("  -o        offset (default 0)\n")
  fp.write("  -d        base directory (default './')\n")
  fp.write("  -M <fn>   output tilemap filename (JSON)\n")
  fp.write("  -S <fn>   output tileset (PNG)\n")
  fp.write("  -N <fn>   outpt tile name file (CSV)\n")
  fp.write("  -R <fn>   outpt tile rule file (CSV)\n")
  fp.write("  -T <#>    type of tilemap to use ('simple', 'cross', 'square')\n")
  fp.write("  -V        verbose\n")
  fp.write("  -D        debug\n")
  fp.write("  -h        help (this screen)\n")
  fp.write("\n")

fn = ""

try:
  opts, args = getopt.getopt(sys.argv[1:], "hvVi:s:o:M:S:Dd:N:R:T:", ["help", "version"])
except getopt.GetoptError as err:
  print(err)
  usage(sys.stderr)
  sys.exit(-1)

for o,a in opts:
  if o in ("-h", "--help"):
    usage(sys.stdout)
    sys.exit(0)
  elif o in ("-v", "--version"):
    usage(sys.stdout)
    sys.exit(0)
  elif o == "-i":
    fn = a
  elif o == "-s":
    info["stride"][0] = int(a)
    info["stride"][1] = int(a)
  elif o == "-o":
    info["offset"][0] = int(a)
    info["offset"][1] = int(a)

  elif o == "-d":
    info["opt"]["basedir"] = a

  elif o == "-S":
    info["tileset"]["fn"] = a
    info["tileset"]["realize"] = True
  elif o == "-M":
    info["tilemap"]["fn"] = a
    info["tilemap"]["realize"] = True

  elif o == "-R":
    info["tilerule"]["fn"] = a
    info["tilerule"]["realize"] = True
  elif o == "-N":
    info["tilename"]["fn"] = a
    info["tilename"]["realize"] = True

  elif o == "-D":
    info["opt"]["debug"] = True

  elif o == "-T":
    info["opt"]["neighbor_type"] = a

if len(fn) == 0:
  sys.stderr.write("provide input map (png)\n")
  usage(sys.stderr)
  sys.exit(-1)

def debug_print_tilemap(tile_map):
  tile_r = len(tile_map)
  tile_c = len(tile_map[0])

  for it_r in range(tile_r):
    row = []
    for it_c in range(tile_c):
      chr_code = '.'
      if tile_map[it_r][it_c] < len(id2chr_map):
        chr_code = id2chr_map[tile_map[it_r][it_c]]
      row.append( chr_code )
    print( " ".join(row) )


def debug_print_adj(data):

  block_adj   = data["block_adj"]
  max_tile_id = data["uniq_tile_id"]
  block_adj   = data["block_adj"]
  tile_id_superblock = data["tile_id_superblock"]

  idir_map = ["+x", "-x", "+y", "-y", "+z", "-z" ]


  for tile_id in range(max_tile_id):

    for idir in range(6):
      a = str(tile_id)
      if a in block_adj[idir]:
        for b in block_adj[idir][a]:
          print("s", a, "--(", idir_map[idir], ")->", b)

          a_block = [ [ -1, -1, -1 ], [-1, -1, -1 ], [-1, -1, -1] ]
          b_block = [ [ -1, -1, -1 ], [-1, -1, -1 ], [-1, -1, -1] ]

          if a!="0":
            a_block = tile_id_superblock[a]["block"]
          if b!="0":
            b_block = tile_id_superblock[b]["block"]

          for r in range(3):
            print("  ", " ".join( map(lambda _a: str(_a), a_block[r]) ), "    ", " ".join( map(lambda _a: str(_a), b_block[r]) ) )

          print("")



def debug_png_adj(data):
  pixel_stride = 8
  pixel_margin = 2
  upscale = 8

  ele_count = [ 2, 3, 2]
  u = upscale*pixel_stride + pixel_margin

  png_width = u*(ele_count[0] + ele_count[1] + ele_count[2]) + pixel_margin

  max_tile_id = data["uniq_tile_id"]
  block_adj = data["block_adj"]

  png_height = 4

  for tile_id in range(max_tile_id):

    dir_count = [0,0,0,0]

    #pxl_dat = [ [0]*png_col for _i in range(png_row) ]

    for idir in range(4):
      block_a_id = str(tile_id)
      if block_a_id in block_adj[idir]:
        count = 0
        for block_b_id in block_adj[idir][block_a_id]:
          count += 1
        dir_count[idir] = count



    side_h = dir_count[0]
    if side_h < dir_count[1]: side_h = dir_count[1]

    print(">dir>", dir_count[0], dir_count[1], dir_count[2], dir_count[3])

    pxl_h = side_h*u + dir_count[2]*u + dir_count[3]*u
    png_height += pxl_h

    #ofn = "png/t" + str(tile_id) + ".png"
    #w = png.Writer( png_width, pxl_h, greyscale=False )
    #png_ofp = open(ofn, "wb")
    #w.write(png_ofp, pxl_dat)
    #png_ofp.close()

    print(">>> tile_id:", tile_id, "pxl_h:", pxl_h)

    print(">>tile_id:", tile_id)

  block_adj = data["block_adj"]

  print("png_row:", png_width, "png_height:", png_height)

def countVal(ele): return ele["count"]
def create_tileset_png_ORIG(info, pxl_lib, tilecount_map):

  max_tile_id = info["max_tile_id"]

  stride_c, stride_r  = info["stride"][0], info["stride"][1]

  tile_a = []
  for key in tilecount_map:
    tile_a.append( { "key": key, "count": tilecount_map[key], "start_pos": [-1,-1] } )
  tileset_dim = int(math.ceil( math.sqrt(float(max_tile_id)) ))

  info["tileset"]["count"] = len(tile_a)
  info["tileset"]["width"] = tileset_dim
  info["tileset"]["height"] = tileset_dim
  info["tileset"]["stride"] = [ stride_c, stride_r ]

  for idx,ele in enumerate(tile_a):
    sc = (idx % tileset_dim)*stride_c
    sr = int(idx / tileset_dim)*stride_c
    tile_a[idx]["start_pos"][0] = sr
    tile_a[idx]["start_pos"][1] = sc

  png_row = tileset_dim * stride_r
  png_col = tileset_dim * stride_c

  pxl_dat = []
  for r in range(png_row):
    pxl_row = []
    for c in range(png_col):
      pxl_row.append(0)
      pxl_row.append(0)
      pxl_row.append(0)
    pxl_dat.append(pxl_row)

  for ele in tile_a:
    key = ele["key"]
    tile_dat = pxl_lib[key]
    for idx_r in range(stride_r):
      for idx_c in range(stride_c):
        pxl_r = ele["start_pos"][0] + idx_r
        pxl_c = 3*ele["start_pos"][1] + 3*idx_c

        _r = tile_dat[idx_r*3*stride_c + 3*idx_c + 0]
        _g = tile_dat[idx_r*3*stride_c + 3*idx_c + 1]
        _b = tile_dat[idx_r*3*stride_c + 3*idx_c + 2]

        pxl_dat[pxl_r][pxl_c+0] = tile_dat[idx_r*3*stride_c + 3*idx_c + 0]
        pxl_dat[pxl_r][pxl_c+1] = tile_dat[idx_r*3*stride_c + 3*idx_c + 1]
        pxl_dat[pxl_r][pxl_c+2] = tile_dat[idx_r*3*stride_c + 3*idx_c + 2]

  ofn = info["tileset"]["fn"]

  w = png.Writer( png_col, png_row, greyscale=False )
  png_ofp = open(ofn, "wb")
  w.write(png_ofp, pxl_dat)
  png_ofp.close()

# from tile_id_pxl, create a tileset PNG
# (map from tile id to (stride_r x stride_c)
# tile png)
#
def create_tileset_png(info, tile_id_pxl):

  max_tile_id = info["max_tile_id"]

  stride_c, stride_r  = info["stride"][0], info["stride"][1]

  tile_a = []
  for tile_id in range(1, len(tile_id_pxl)):
    tile_a.append( { "tile_id": tile_id, "start_pos": [-1,-1], "pxl_dat": tile_id_pxl[tile_id] } )
  tileset_dim = int(math.ceil( math.sqrt(float(max_tile_id)) ))

  info["tileset"]["count"] = len(tile_a)
  info["tileset"]["width"] = tileset_dim
  info["tileset"]["height"] = tileset_dim
  info["tileset"]["stride"] = [ stride_c, stride_r ]

  for idx,ele in enumerate(tile_a):
    sc = (idx % tileset_dim)*stride_c
    sr = int(idx / tileset_dim)*stride_c
    tile_a[idx]["start_pos"][0] = sr
    tile_a[idx]["start_pos"][1] = sc

  png_row = tileset_dim * stride_r
  png_col = tileset_dim * stride_c

  pxl_dat = []
  for r in range(png_row):
    pxl_row = []
    for c in range(png_col):
      pxl_row.append(0)
      pxl_row.append(0)
      pxl_row.append(0)
    pxl_dat.append(pxl_row)

  for ele in tile_a:
    tile_dat = ele["pxl_dat"]
    for idx_r in range(stride_r):
      for idx_c in range(stride_c):
        pxl_r = ele["start_pos"][0] + idx_r
        pxl_c = 3*ele["start_pos"][1] + 3*idx_c

        _r = tile_dat[idx_r*3*stride_c + 3*idx_c + 0]
        _g = tile_dat[idx_r*3*stride_c + 3*idx_c + 1]
        _b = tile_dat[idx_r*3*stride_c + 3*idx_c + 2]

        pxl_dat[pxl_r][pxl_c+0] = tile_dat[idx_r*3*stride_c + 3*idx_c + 0]
        pxl_dat[pxl_r][pxl_c+1] = tile_dat[idx_r*3*stride_c + 3*idx_c + 1]
        pxl_dat[pxl_r][pxl_c+2] = tile_dat[idx_r*3*stride_c + 3*idx_c + 2]

  ofn = info["tileset"]["fn"]

  w = png.Writer( png_col, png_row, greyscale=False )
  png_ofp = open(ofn, "wb")
  w.write(png_ofp, pxl_dat)
  png_ofp.close()

def export_tiled_json(info, tm):

  stride_r = info["stride"][0]
  stride_c = info["stride"][1]

  tile_r = len(tm)
  tile_c = len(tm[0])

  tiled_map_template = {
    "backgroundcolor" : "#ffffff",
    #"class": "-",
    "height": tile_r,
    "width": tile_c,
    "layers": [],
    "nextobjectid": 1,
    "orientation": "orthogonal",
    "properties": [ ],
    "renderorder" : "right-down",
    "tileheight": stride_r,
    "tilewidth": stride_c,
    "tilesets": [],
    #"tiledversion":"1.0.3",
    "version": 1
  }

  tiled_layer_template = {
    "data": [],
    "height" : tile_r,
    "width": tile_c,
    "name": "main",
    "opacity": 1,
    "properties": [],
    "type":"tilelayer",
    "visible":True,
    "x": 0,
    "y": 0
  }

  tiled_tileset_template = {
    #"firstgid": 1,
    "firstgid": info["firstgid"],
    "columns": info["tileset"]["width"],
    "name":"tileset",
    #"name":"",
    "image": info["tileset"]["fn"],
    "imageheight": info["tileset"]["height"] * info["tileset"]["stride"][1],
    "imagewidth": info["tileset"]["width"] * info["tileset"]["stride"][0],
    "margin": 0,
    #"properties":[],
    "spacing": 0,
    "tilecount": info["tileset"]["count"],
    "tileheight": info["tileset"]["stride"][1],
    "tilewidth": info["tileset"]["stride"][0]
  }

  json_data = tiled_map_template
  json_data["layers"].append( tiled_layer_template )
  json_data["tilesets"].append( tiled_tileset_template )

  for it_r in range(tile_r):
    row = []
    for it_c in range(tile_c):
      json_data["layers"][0]["data"].append( tm[it_r][it_c] )

  ofp = open( info["tilemap"]["fn"], "wb" )
  ofp.write( json.dumps( json_data, indent=2 ).encode() )
  ofp.close()
  return json_data

def export_tile_name_csv(info, tile_map, tile_count):
  ofn = info["tilename"]["fn"]
  max_tile_idx = info["max_tile_id"]
  fp = open(ofn, "w")
  for tile_idx in range(max_tile_idx+1):

    u = 1
    if info["opt"]["tile_weight"] == "sqrt":
      u = 1 + int( math.sqrt(float(tile_count[tile_idx])) )
    elif info["opt"]["tile_weight"] == "linear":
      u = tile_count[tile_idx]
    elif info["opt"]["tile_weight"] == "inverse":
      if tile_count[tile_idx] == 0:
        u = 0
      else:
        u = 1.0/float(tile_count[tile_idx])
    elif info["opt"]["tile_weight"] == "inversesqrt":
      if tile_count[tile_idx] == 0:
        u = 0
      else:
        u = math.sqrt(float(tile_count[tile_idx]))
        u = 1.0/float(u)

        ## DEBUG
        u = math.pow(float(tile_count[tile_idx]), -1.0/4.0)

    if tile_idx==0: u=0
    #fp.write( "%i,%i,%i\n" % (tile_idx, tile_idx, u) )
    fp.write( "%i,%i,%f\n" % (tile_idx, tile_idx, float(u)) )

    #fp.write( "%i,%i,%i\n" % (tile_idx, tile_idx, tile_count[tile_idx]))
  fp.close()

def __export_tile_rule_csv(info, tile_map):
  ofn = info["tilerule"]["fn"]

  tile_r = len(tile_map)
  tile_c = len(tile_map[0])

  tile_rule = {}

  for idx_r in range(tile_r):
    for idx_c in range(tile_c):

      src_tile = tile_map[idx_r][idx_c]
      cp = idx_c+1
      cn = idx_c-1
      rp = idx_r+1
      rn = idx_r-1

      if cp < tile_c:
        dst_tile = tile_map[idx_r][cp]
        key = "%i,%i,%i" % (src_tile, dst_tile, 0)
        tile_rule[key] = 1
        key = "%i,%i,%i" % (dst_tile, src_tile, 1)
        tile_rule[key] = 1

      if cn >= 0:
        dst_tile = tile_map[idx_r][cn]
        key = "%i,%i,%i" % (src_tile, dst_tile, 1)
        tile_rule[key] = 1
        key = "%i,%i,%i" % (dst_tile, src_tile, 0)
        tile_rule[key] = 1

      if rp < tile_r:
        dst_tile = tile_map[rp][idx_c]
        key = "%i,%i,%i" % (src_tile, dst_tile, 2)
        tile_rule[key] = 1
        key = "%i,%i,%i" % (dst_tile, src_tile, 3)
        tile_rule[key] = 1

      if rn >= 0:
        dst_tile = tile_map[rn][idx_c]
        key = "%i,%i,%i" % (src_tile, dst_tile, 3)
        tile_rule[key] = 1
        key = "%i,%i,%i" % (dst_tile, src_tile, 2)
        tile_rule[key] = 1

      key = "%i,%i,%i" % (0, src_tile, 4)
      tile_rule[key] = 1
      key = "%i,%i,%i" % (0, src_tile, 5)
      tile_rule[key] = 1

      key = "%i,%i,%i" % (src_tile, 0, 4)
      tile_rule[key] = 1
      key = "%i,%i,%i" % (src_tile, 0, 5)
      tile_rule[key] = 1


  if info["opt"]["tile_zero_boundary_condition"]:
    for idx_r in range(tile_r):
      l_tile = tile_map[idx_r][0]
      key = "%i,%i,%i" % (0, l_tile, 0)
      tile_rule[key] = 1
      key = "%i,%i,%i" % (l_tile, 0, 1)
      tile_rule[key] = 1

      r_tile = tile_map[idx_r][tile_c-1]
      key = "%i,%i,%i" % (r_tile, 0, 0)
      tile_rule[key] = 1
      key = "%i,%i,%i" % (0, r_tile, 1)
      tile_rule[key] = 1

    for idx_c in range(tile_c):
      u_tile = tile_map[0][idx_c]
      key = "%i,%i,%i" % (0, u_tile, 3)
      tile_rule[key] = 1
      key = "%i,%i,%i" % (u_tile, 0, 2)
      tile_rule[key] = 1

      b_tile = tile_map[tile_r-1][idx_c]
      key = "%i,%i,%i" % (0, b_tile, 2)
      tile_rule[key] = 1
      key = "%i,%i,%i" % (b_tile, 0, 3)
      tile_rule[key] = 1

  ofp = open(ofn, "w")
  for key in tile_rule:
    ofp.write( "%s,%i\n" % (key, tile_rule[key]) )
  ofp.close()

def ___export_tile_rule_csv(info, tile_map):
  ofn = info["tilerule"]["fn"]

  tile_r = len(tile_map)
  tile_c = len(tile_map[0])

  tile_rule = {}

  # pngs and tilemap have the Y direction
  # going downwards, so we need to interpret
  # the 'row positive' (rp) and 'row negative' (rn)
  # approrpriately
  #

  for idx_r in range(tile_r):
    for idx_c in range(tile_c):

      src_tile = tile_map[idx_r][idx_c]
      cp = idx_c+1
      cn = idx_c-1
      rp = idx_r-1
      rn = idx_r+1

      if cp < tile_c:
        dst_tile = tile_map[idx_r][cp]
        key = "%i,%i,%i" % (src_tile, dst_tile, 0)
        if not (key in tile_rule): tile_rule[key] = 0
        tile_rule[key] += 1
        key = "%i,%i,%i" % (dst_tile, src_tile, 1)
        if not (key in tile_rule): tile_rule[key] = 0
        tile_rule[key] += 1

      if cn >= 0:
        dst_tile = tile_map[idx_r][cn]
        key = "%i,%i,%i" % (src_tile, dst_tile, 1)
        if not (key in tile_rule): tile_rule[key] = 0
        tile_rule[key] += 1
        key = "%i,%i,%i" % (dst_tile, src_tile, 0)
        if not (key in tile_rule): tile_rule[key] = 0
        tile_rule[key] += 1

      if rp >= 0:
        dst_tile = tile_map[rp][idx_c]
        key = "%i,%i,%i" % (src_tile, dst_tile, 2)
        if not (key in tile_rule): tile_rule[key] = 0
        tile_rule[key] += 1
        key = "%i,%i,%i" % (dst_tile, src_tile, 3)
        if not (key in tile_rule): tile_rule[key] = 0
        tile_rule[key] += 1

      if rn < tile_r:
        dst_tile = tile_map[rn][idx_c]
        key = "%i,%i,%i" % (src_tile, dst_tile, 3)
        if not (key in tile_rule): tile_rule[key] = 0
        tile_rule[key] += 1
        key = "%i,%i,%i" % (dst_tile, src_tile, 2)
        if not (key in tile_rule): tile_rule[key] = 0
        tile_rule[key] += 1

      key = "%i,%i,%i" % (0, src_tile, 4)
      if not (key in tile_rule): tile_rule[key] = 0
      tile_rule[key] += 1
      key = "%i,%i,%i" % (0, src_tile, 5)
      if not (key in tile_rule): tile_rule[key] = 0
      tile_rule[key] += 1

      key = "%i,%i,%i" % (src_tile, 0, 4)
      if not (key in tile_rule): tile_rule[key] = 0
      tile_rule[key] += 1
      key = "%i,%i,%i" % (src_tile, 0, 5)
      if not (key in tile_rule): tile_rule[key] = 0
      tile_rule[key] += 1


  if info["opt"]["tile_zero_boundary_condition"]:
    for idx_r in range(tile_r):
      l_tile = tile_map[idx_r][0]
      key = "%i,%i,%i" % (0, l_tile, 0)
      if not (key in tile_rule): tile_rule[key] = 0
      tile_rule[key] += 1
      key = "%i,%i,%i" % (l_tile, 0, 1)
      if not (key in tile_rule): tile_rule[key] = 0
      tile_rule[key] += 1

      r_tile = tile_map[idx_r][tile_c-1]
      key = "%i,%i,%i" % (r_tile, 0, 0)
      if not (key in tile_rule): tile_rule[key] = 0
      tile_rule[key] += 1
      key = "%i,%i,%i" % (0, r_tile, 1)
      if not (key in tile_rule): tile_rule[key] = 0
      tile_rule[key] += 1

    for idx_c in range(tile_c):
      u_tile = tile_map[0][idx_c]
      key = "%i,%i,%i" % (0, u_tile, 3)
      if not (key in tile_rule): tile_rule[key] = 0
      tile_rule[key] += 1
      key = "%i,%i,%i" % (u_tile, 0, 2)
      if not (key in tile_rule): tile_rule[key] = 0
      tile_rule[key] += 1

      b_tile = tile_map[tile_r-1][idx_c]
      key = "%i,%i,%i" % (0, b_tile, 2)
      if not (key in tile_rule): tile_rule[key] = 0
      tile_rule[key] += 1
      key = "%i,%i,%i" % (b_tile, 0, 3)
      if not (key in tile_rule): tile_rule[key] = 0
      tile_rule[key] += 1

  ofp = open(ofn, "w")

  if info["opt"]["rule_weight"]:
    for key in tile_rule:
      ofp.write( "%s,%i\n" % (key, tile_rule[key]) )
  else:
    for key in tile_rule:
      ofp.write( "%s,%i\n" % (key, 1) )
  ofp.close()

def export_tile_rule_csv(info, tile_map, block_adj):
  ofn = info["tilerule"]["fn"]

  tile_r = len(tile_map)
  tile_c = len(tile_map[0])

  tile_rule = {}

  ofp = open(ofn, "w")

  for idir,m in enumerate(block_adj):

    for src_key in m:
      for dst_key in m[src_key]:
        w = 1.0
        if info["opt"]["rule_weight"]:
          s = m[src_key][dst_key]["count"]
        ofp.write("%s,%s,%i,%f\n" % (src_key, dst_key, idir, float(w)))

  ofp.close()


img = Image.open(fn).convert("RGB")
pxl = img.load()
sz = img.size
img.close()

info["size"] = sz

tile_c = int(sz[0]/info["stride"][0])
tile_r = int(sz[1]/info["stride"][1])

#tile_count = []
#uniq_pixel = {}
#uniq_tile = {}
#uniq_tile_key_id = {}
#pxl_tileset = {}
#tile_map = []

uniq_tile_id = 1
info["firstgid"] = uniq_tile_id

## simple tilemap that uses independent neighbor
##
def compute_tilemap_0(data):
  uniq_tile_id = data["uniq_tile_id"]
  tile_count = data["tile_count"]
  tile_map = data["tile_map"]
  uniq_tile = data["uniq_tile"]
  uniq_tile_key_id = data["uniq_tile_key_id"]
  pxl_tileset = data["pxl_tileset"]
  uniq_pixel = data["uniq_pixel"]

  tile_id_pxl = []

  pxl = data["pxl"]

  info = data["info"]
  sc = info["stride"][0]
  sr = info["stride"][1]

  sz = info["size"]
  tile_c = int(sz[0]/info["stride"][0])
  tile_r = int(sz[1]/info["stride"][1])


  for it_r in range(tile_r):
    tile_map.append([])
    for it_c in range(tile_c):
      tile_map[it_r].append(-1)

  for it_r in range(tile_r):
    for it_c in range(tile_c):
      tile_a = []

      pxl_tile_cur = []
      for r in range(sr):
        for c in range(sc):
          rgb = pxl[ it_c*sc + c , it_r*sr + r ]

          s_r = "%0.2x" % rgb[0]
          s_g = "%0.2x" % rgb[1]
          s_b = "%0.2x" % rgb[1]

          tile_a.append(s_r)
          tile_a.append(s_g)
          tile_a.append(s_b)

          key = str(rgb[0]) + ":" + str(rgb[1]) + ":" + str(rgb[2])
          if not (key in uniq_pixel):
            uniq_pixel[key] = 0
          uniq_pixel[key]+=1

          pxl_tile_cur.append( rgb[0] )
          pxl_tile_cur.append( rgb[1] )
          pxl_tile_cur.append( rgb[2] )

      tile_key = "".join(tile_a)
      if not (tile_key in uniq_tile):
        pxl_tileset[tile_key] = pxl_tile_cur

        uniq_tile[tile_key] = 0
        uniq_tile_key_id[tile_key] = uniq_tile_id
        uniq_tile_id+=1

      n = len(tile_id_pxl)
      for idx in range(n, uniq_tile_key_id[tile_key] + 1):
        tile_id_pxl.append( {} )

      tile_id_pxl[ uniq_tile_key_id[tile_key] ] = pxl_tileset[tile_key]

      uniq_tile[tile_key]+=1
      tile_map[it_r][it_c] = uniq_tile_key_id[tile_key]

  for i in range(uniq_tile_id):
    tile_count.append(0)
  for tile_key in uniq_tile_key_id:
    tile_id = uniq_tile_key_id[tile_key]
    count = uniq_tile[tile_key]
    tile_count[ tile_id ] = count

  data["uniq_tile_id"] = uniq_tile_id
  data["base_pxl_tileset"] = pxl_tileset
  data["base_uniq_tile"] = uniq_tile
  data["tile_id_pxl"] = tile_id_pxl

## cross pattern neighbor (non diagonal neighbor)
##
def compute_tilemap_1(data):

  base_data = {
    "info" : data["info"],

    "pxl": data["pxl"],
    "pxl_tileset": {},
    "uniq_pixel": {},

    "uniq_tile_id": 1,
    "tile_count": [],

    "uniq_tile": {},
    "uniq_tile_key_id": {},

    "base_uniq_tile" : {},
    "base_pxl_tileset": {},

    "tile_map": []
  }

  compute_tilemap_0(base_data)

  data["base_pxl_tileset"] = base_data["pxl_tileset"]
  data["base_uniq_tile"] = base_data["uniq_tile"]
  data["base_tile_map"] = base_data["tile_map"]
  data["uniq_pixel"] = base_data["uniq_pixel"]

  uniq_tile_id = data["uniq_tile_id"]
  tile_count = data["tile_count"]
  tile_map = data["tile_map"]
  uniq_tile = data["uniq_tile"]
  uniq_tile_key_id = data["uniq_tile_key_id"]

  info = data["info"]
  window_c = 3
  window_r = 3

  window_c0 = int(window_c/2)
  window_r0 = int(window_r/2)

  sz = info["size"]
  tile_c = int(sz[0]/info["stride"][0])
  tile_r = int(sz[1]/info["stride"][1])

  window_nei = [ [-1,0], [0,-1], [0,0], [0,1], [1,0] ]

  for it_r in range(tile_r):
    tile_map.append([])
    for it_c in range(tile_c):
      tile_map[it_r].append(-1)

  for it_r in range(tile_r):
    for it_c in range(tile_c):
      tile_a = []

      block_key_a = []

      for nei in window_nei:
        pos_r = it_r + nei[0]
        pos_c = it_c + nei[1]

        if ((pos_c < 0) or
            (pos_r < 0) or
            (pos_c >= tile_c) or
            (pos_r >= tile_r)):
          block_key_a.append( str(-1) )
        else:
          block_key_a.append( str(base_data["tile_map"][pos_r][pos_c]) )

      block_key = ":".join(block_key_a)

      if not (block_key in uniq_tile):
        uniq_tile[block_key] = 0
        uniq_tile_key_id[block_key] = uniq_tile_id
        uniq_tile_id+=1
      uniq_tile[block_key]+=1
      tile_map[it_r][it_c] = uniq_tile_key_id[block_key]

  for i in range(uniq_tile_id):
    tile_count.append(0)
  for block_key in uniq_tile_key_id:
    tile_id = uniq_tile_key_id[block_key]
    count = uniq_tile[block_key]
    tile_count[ tile_id ] = count

  data["uniq_tile_id"] = uniq_tile_id

  ## reconstruct tileset png info
  ##
  tile_id_pxl = []
  for i in range(uniq_tile_id):
    tile_id_pxl.append({})

  for it_r in range(tile_r):
    for it_c in range(tile_c):
      base_tile_id = base_data["tile_map"][it_r][it_c]
      cur_tile_id = tile_map[it_r][it_c]

      tile_id_pxl[ cur_tile_id ] = base_data["tile_id_pxl"][base_tile_id]

  data["tile_id_pxl"] = tile_id_pxl
  data["tile_map"] = tile_map

def block_overlap(idir, b0,b1):

  # idir:
  #  0 : +x
  #  1 : -x
  #  2 : +y
  #  3 : -y

  n_r = len(b0)
  n_c = len(b0[0])

  if idir==0:
    for r in range(n_r):
      for c in range(1,n_c):
        if b0[r][c] != b1[r][c-1]: return False
  elif idir==1:
    for r in range(n_r):
      for c in range(0,n_c-1):
        if b0[r][c] != b1[r][c+1]: return False

  elif idir==2:
    for r in range(1,n_r):
      for c in range(n_c):
        if b0[r][c] != b1[r-1][c]: return False
    #for r in range(0,n_r-1):
    #  for c in range(n_c):
    #    if b0[r][c] != b1[r+1][c]: return False

  elif idir==2:
    for r in range(0,n_r-1):
      for c in range(n_c):
        if b0[r][c] != b1[r+1][c]: return False
    #for r in range(1,n_r):
    #  for c in range(n_c):
    #    if b0[r][c] != b1[r-1][c]: return False


  else: return False

  return True


## 3x3 pattern neighbor
##
def compute_tilemap_2(data):

  base_data = {
    "info" : data["info"],

    "pxl": data["pxl"],
    "pxl_tileset": {},
    "uniq_pixel": {},

    "uniq_tile_id": 1,
    "tile_count": [],

    "uniq_tile": {},
    "uniq_tile_key_id": {},

    "base_uniq_tile" : {},
    "base_pxl_tileset": {},

    "block_adj": [ {}, {}, {}, {}, {}, {} ],

    "tile_map": []
  }


  compute_tilemap_0(base_data)

  data["base_pxl_tileset"] = base_data["pxl_tileset"]
  data["base_uniq_tile"] = base_data["uniq_tile"]
  data["base_tile_map"] = base_data["tile_map"]
  data["uniq_pixel"] = base_data["uniq_pixel"]

  uniq_tile_id = data["uniq_tile_id"]
  tile_count = data["tile_count"]
  tile_map = data["tile_map"]
  uniq_tile = data["uniq_tile"]
  uniq_tile_key_id = data["uniq_tile_key_id"]

  block_adj = data["block_adj"]

  info = data["info"]
  window_c = 3
  window_r = 3

  window_c0 = int(window_c/2)
  window_r0 = int(window_r/2)

  sz = info["size"]
  tile_c = int(sz[0]/info["stride"][0])
  tile_r = int(sz[1]/info["stride"][1])

  #tile_map = []

  for it_r in range(tile_r):
    tile_map.append([])
    for it_c in range(tile_c):
      tile_map[it_r].append(-1)

  tile_id_superblock = {}
  for it_r in range(tile_r):
    for it_c in range(tile_c):
      tile_a = []

      block_key_a = []

      superblock = [[0]*window_c for _i in range(window_r)]
      for idx_r in range(window_r):
        for idx_c in range(window_c):
          pos_c = it_c - window_c0 + idx_c
          pos_r = it_r - window_r0 + idx_r

          if ((pos_c < 0) or
              (pos_r < 0) or
              (pos_c >= tile_c) or
              (pos_r >= tile_r)):
            block_key_a.append( str(-1) )
            superblock[idx_r][idx_c] = -1
          else:
            block_key_a.append( str(base_data["tile_map"][pos_r][pos_c]) )
            superblock[idx_r][idx_c] = base_data["tile_map"][pos_r][pos_c]


      block_key = ":".join(block_key_a)


      if not (block_key in uniq_tile):
        uniq_tile[block_key] = 0
        uniq_tile_key_id[block_key] = uniq_tile_id
        uniq_tile_id+=1
      uniq_tile[block_key] += 1
      tile_map[it_r][it_c] = uniq_tile_key_id[block_key]

      tile_id_superblock[str(uniq_tile_key_id[block_key])] = {
        "id": uniq_tile_key_id[block_key],
        "key": block_key,
        "block": superblock
      }

      #print("adding", it_r, it_c, uniq_tile_key_id[block_key], "(", block_key, ")")

  data["tile_id_superblock"] = tile_id_superblock

  ### DEBUG
  #for id_key in tile_id_superblock:
  #  print(id_key , tile_id_superblock[id_key])

  for i in range(uniq_tile_id):
    tile_count.append(0)
  for block_key in uniq_tile_key_id:
    tile_id = uniq_tile_key_id[block_key]
    count = uniq_tile[block_key]
    tile_count[ tile_id ] = count

  data["uniq_tile_id"] = uniq_tile_id

  ## Reconstruct tileset png info.
  ## That is, get the middle stride x stride png
  ## tile in the middle of the block so reconstructing
  ## the tileset is easier.
  ##
  tile_id_pxl = []
  for i in range(uniq_tile_id):
    tile_id_pxl.append({})

  for it_r in range(tile_r):
    for it_c in range(tile_c):
      base_tile_id = base_data["tile_map"][it_r][it_c]
      cur_tile_id = tile_map[it_r][it_c]

      tile_id_pxl[ cur_tile_id ] = base_data["tile_id_pxl"][base_tile_id]

  uniq_adj_count = 0
  for src_block_id in range(1, uniq_tile_id):
    for dst_block_id in range(1, uniq_tile_id):
      src_block = tile_id_superblock[ str(src_block_id) ]["block"]
      dst_block = tile_id_superblock[ str(dst_block_id) ]["block"]

      for idir in range(4):
        if block_overlap(idir, src_block, dst_block):

          a = str(src_block_id)
          b = str(dst_block_id)

          if not (a in block_adj[idir]):
            block_adj[idir][a] = {}
          if not (b in block_adj[idir][a]):
            block_adj[idir][a][b] = {
              "src_id": src_block_id,
              "dst_id": dst_block_id,
              "count": 0
            }

            uniq_adj_count += 1

          block_adj[idir][a][b]["count"] += 1

          #print("overlap(", src_block_id, dst_block_id, "):", idir, src_block, dst_block)
        else:
          #print("xxxxxxx(", src_block_id, dst_block_id, "):", idir, src_block, dst_block)
          pass

  for it_r in range(tile_r):

    i_a = 0
    i_b = tile_map[it_r][0]
    
    s_a = str(i_a)
    s_b = str(i_b)

    idir = 0
    if not (s_a in block_adj[idir]): block_adj[idir][s_a] = {}
    if not (s_b in block_adj[idir][s_a]): block_adj[idir][s_a][s_b] = { "src_id": i_a, "dst_id": i_b, "count": 0 }
    block_adj[idir][s_a][s_b]["count"] += 1

    idir = 1
    if not (s_b in block_adj[idir]): block_adj[idir][s_b] = {}
    if not (s_a in block_adj[idir][s_b]): block_adj[idir][s_b][s_a] = { "src_id": i_b, "dst_id": i_a, "count": 0 }
    block_adj[idir][s_b][s_a]["count"] += 1

    i_a = tile_map[it_r][tile_c-1]
    i_b = 0
    
    s_a = str(i_a)
    s_b = str(i_b)

    idir = 0
    if not (s_a in block_adj[idir]): block_adj[idir][s_a] = {}
    if not (s_b in block_adj[idir][s_a]): block_adj[idir][s_a][s_b] = { "src_id": i_a, "dst_id": i_b, "count": 0 }
    block_adj[idir][s_a][s_b]["count"] += 1

    idir = 1
    if not (s_b in block_adj[idir]): block_adj[idir][s_b] = {}
    if not (s_a in block_adj[idir][s_b]): block_adj[idir][s_b][s_a] = { "src_id": i_b, "dst_id": i_a, "count": 0 }
    block_adj[idir][s_b][s_a]["count"] += 1

  for it_c in range(tile_c):

    i_a = tile_map[0][it_c]
    i_b = 0
    
    s_a = str(i_a)
    s_b = str(i_b)

    idir = 2
    #idir = 3
    if not (s_a in block_adj[idir]): block_adj[idir][s_a] = {}
    if not (s_b in block_adj[idir][s_a]): block_adj[idir][s_a][s_b] = { "src_id": i_a, "dst_id": i_b, "count": 0 }
    block_adj[idir][s_a][s_b]["count"] += 1

    idir = 3
    #idir = 2
    if not (s_b in block_adj[idir]): block_adj[idir][s_b] = {}
    if not (s_a in block_adj[idir][s_b]): block_adj[idir][s_b][s_a] = { "src_id": i_b, "dst_id": i_a, "count": 0 }
    block_adj[idir][s_b][s_a]["count"] += 1

    i_a = 0
    i_b = tile_map[tile_r-1][it_c]
    
    s_a = str(i_a)
    s_b = str(i_b)

    idir = 2
    #idir = 3
    if not (s_a in block_adj[idir]): block_adj[idir][s_a] = {}
    if not (s_b in block_adj[idir][s_a]): block_adj[idir][s_a][s_b] = { "src_id": i_a, "dst_id": i_b, "count": 0 }
    block_adj[idir][s_a][s_b]["count"] += 1

    idir = 3
    #idir = 2
    if not (s_b in block_adj[idir]): block_adj[idir][s_b] = {}
    if not (s_a in block_adj[idir][s_b]): block_adj[idir][s_b][s_a] = { "src_id": i_b, "dst_id": i_a, "count": 0 }
    block_adj[idir][s_b][s_a]["count"] += 1

  block_adj[4]["0"] = {}
  block_adj[5]["0"] = {}
  for block_id in range(1, uniq_tile_id):
    i_a = 0
    i_b = block_id
    s_a = str(i_a)
    s_b = str(i_b)

    if not (s_b in block_adj[4]): block_adj[4][s_b] = {}
    if not (s_b in block_adj[5]): block_adj[5][s_b] = {}

    block_adj[4][s_a][s_b] = { "src_id": i_a, "dst_id": i_b, "count": 1 }
    block_adj[4][s_b][s_a] = { "src_id": i_b, "dst_id": i_a, "count": 1 }
    block_adj[5][s_a][s_b] = { "src_id": i_a, "dst_id": i_b, "count": 1 }
    block_adj[5][s_b][s_a] = { "src_id": i_b, "dst_id": i_a, "count": 1 }


  data["tile_id_pxl"] = tile_id_pxl
  data["tile_map"] = tile_map


####
####
####


data = {
  "info" : info,

  "pxl": pxl,
  "pxl_tileset": {},
  "uniq_pixel": {},

  "uniq_tile_id": 1,
  "tile_count": [],

  "uniq_tile": {},
  "uniq_tile_key_id": {},

  "tile_id_superblock": {},

  "block_adj": [ {}, {}, {}, {}, {}, {} ],

  "tile_map": []
}

if info["opt"]["neighbor_type"] == "cross":
  compute_tilemap_1(data)
elif info["opt"]["neighbor_type"] == "square":
  compute_tilemap_2(data)
else:
  compute_tilemap_0(data)
uniq_tile_id = data["uniq_tile_id"]

## DEBUG
#for it_r in range(len(data["tile_map"])):
#  for it_c in range(len(data["tile_map"][0])):
#    print(it_r, it_c, data["tile_map"][it_r][it_c])
#  print("")

info["max_tile_id"] = uniq_tile_id-1

#create_tileset_png(data["info"], data["pxl_tileset"], data["uniq_tile"])
#create_tileset_png(data["info"], data["base_pxl_tileset"], data["base_uniq_tile"])


create_tileset_png(data["info"], data["tile_id_pxl"])

uniq_tile_count = 0
for tile_key in data["uniq_tile"]:
  uniq_tile_count+=1

if info["tilemap"]["realize"] or info["tileset"]["realize"]:
  td_map = export_tiled_json(data["info"], data["tile_map"])

if info["tilerule"]["realize"] or info["tilename"]["realize"]:
  export_tile_name_csv(data["info"], data["tile_map"], data["tile_count"])
  export_tile_rule_csv(data["info"], data["tile_map"], data["block_adj"])

if info["opt"]["debug"]:
  debug_print_tilemap(data["tile_map"])
  debug_print_adj(data)

  #debug_png_adj(data)

